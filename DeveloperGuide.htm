<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>WorldGrower Developer Guide</title>
    <link rel="stylesheet" type="text/css" href="worldgrower.css">
  </head>
  <body>
    <h1>WorldGrower Developer Guide</h1>
    <a href="#Coding_Standards">Coding Standards</a><br>
    <a href="#Changelog">Changelog</a><br>
    <a href="#Commit_Messages">Commit Messages</a><br>
    <a href="#Release">Release</a><br>
    <a href="#Debugging">Debugging</a><br>
    <a href="#Overview">Overview</a><br>
    <a href="#Coding_Guidelines">Coding Guidelines</a><br>
    <a href="#Adding_a_new_Action">Adding a new Action</a><br>
    <a href="#Adding_a_new_WorldObject">Adding a new WorldObject</a><br>
    <a href="#Adding_a_new_Goal">Adding a new Goal</a><br>
    <a href="#Adding_a_new_Image">Adding a new Image</a><br>
    <a href="#Adding_a_new_Conversation">Adding a new Conversation</a><br>
    <a href="#Adding_unit_tests">Adding unit tests</a><br>
    <h2><br>
    </h2>
    <h2><a name="Coding_Standards"></a>Coding Standards</h2>
    <br>
    Use the Java Coding conventions: <a
href="http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html">http://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html</a><br>
    <br>
    <h2> <a name="Changelog"></a>Changelog</h2>
    <br>
    When adding changes, be sure to update CHANGES file.<br>
    <br>
    <h2><a name="Commit_Messages"></a>Commit Messages</h2>
    <br>
    A good commit should not only contain good changes, but also include
    a helpful description of them for other developers, people tracking
    regressions, project maintainers, and even yourself in the future.
    There are many style guides on the Web describing best practices for
    documenting your Git commits. <br>
    <br>
    <h2><a name="Release"></a>Release</h2>
    <br>
    WorldGrower is released with Gradle 2.0.<br>
    Download Gradle from <a href="https://gradle.org/gradle-download/">https://gradle.org/gradle-download/</a><br>
    <br>
    run 'gradle -PdoRelease clean release' to create a release.<br>
    <br>
    When creating a new release, a local install4j installation is
    needed.<br>
    The gradle.properties file needs to point the install4j install
    directory:<br>
    install4jHomeDir=C:/Program Files/install4j6<br>
    <br>
    <h2><a name="Debugging"></a>Debugging</h2>
    <br>
    To run in debug&nbsp; mode, start WorldGrower with -DDEBUG=true.<br>
    This allows to view the properties of each WorldObject.<br>
    This also gives access to the commoners overview screen and other
    debug screens.<br>
    <br>
    <h2><a name="Overview"></a>Overview</h2>
    A WorldObject represents an object in the World and has properties.<br>
    Properties such as hit points, gold, name, etc.<br>
    All properties are declared in the Constants class and have types
    like integer, String, List of ids, etc.<br>
    <br>
    Each WorldObject has a unique id, an int with which can be given to
    World instance to retrieve it.<br>
    <br>
    Each intelligent WorldObject can perform actions (ManagedOperation)
    on other WorldObjects.<br>
    For example: person performs CutWoodAction on Tree<br>
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;



    person performs TalkAction with other person<br>
    <br>
    An intelligent WorldObject uses Goal instances to further its goals.<br>
    It uses WorldObjectPriorities to return multiple Goal instances.<br>
    The Goal instances at the beginning of those multiple Goal instances
    have a higher priority than the ones at the end.<br>
    <br>
    <h2><a name="Coding_Guidelines"></a>Coding Guidelines</h2>
    <br>
    under construction<br>
    <br>
    <h2><a name="Adding_a_new_Action"></a>Adding a new Action</h2>
    <br>
    Adding a new Action/ManagedOperation is as follows:<br>
    Create a class implementing ManagedOperation or its subinterfaces
    under org.worldgrower.actions or subpackages.<br>
    There are several interfaces that extend ManagedOperation:<br>
    &nbsp;&nbsp;&nbsp; - MagicSpell for magic spells<br>
    &nbsp;&nbsp;&nbsp; - BuildAction for actions that build something<br>
    <br>
    The <u>execute</u> method changes properties in performer and
    target<br>
    <br>
    The <u>isValidTarget</u> method indicates what properties a target
    should have so that this<br>
    action can be executed on it. Nothing should be assumed about any
    properties the target has.<br>
    So it's best to check with WorldObject::hasProperty.<br>
    <br>
    The <u>distance</u> method determine whether the circumstances are
    correct to execute the action.<br>
    This includes circumstances like location, having certain items in
    the inventory, etc.<br>
    When the distance is 0, the action can be executed.<br>
    When the distance is not 0, the action cannot be executed.<br>
    This method is used when executing a method, and also in the
    pathfinding algorithm A*.<br>
    When the performer needs to be next the target, it's recommended to
    use the Reach class.<br>
    <br>
    The <u>getArgumentRanges</u> method returns ranges for the int[]
    args argument of the execute.<br>
    At this moment, the code only checks whether there are arguments or
    not.<br>
    This has implications for the user interface, as methods without
    argument ranges can be called automatically.<br>
    For actions that expect int[] args, the user interface needs a way
    for the user to pass them along.<br>
    <br>
    The <u>getSimpleDescription</u> method describes the action in a
    simple command.<br>
    <br>
    The <u>getDescription</u> method describes the action as it is used
    in a sentence like:<br>
    "She was " + action.getDescription()<br>
    So for example: "cutting wood", "talking to Adela", etc.<br>
    <br>
    The readResolve needs needs to be present in order for serialization
    to work.<br>
    <br>
    When the class is implemented, it needs to be added to the Actions
    class,<br>
    both as a constant and added to other similar actions.<br>
    <br>
    If the action has int[] args and ArgumentRanges, it needs to be
    added to the GuiMouseListener class,<br>
    so that it appears in the popup menu.<br>
    <br>
    Once an action has been added, it's best to create one or Goals that
    use the action.<br>
    That way, intelligent WorldObjects can also use the new action.<br>
    <br>
    <h2><a name="Adding_a_new_WorldObject"></a>Adding a new WorldObject</h2>
    A new WorldObject probably requires some new properties<br>
    New properties can be added to the Constants class.<br>
    <br>
    When a WorldObject points to another worldObject, it usually uses
    the id.<br>
    That's why there are types like IdList, IdMap, etc.<br>
    WorldObject are sometimes deep copied, which is trickier with direct
    references to other WorldObject instances.<br>
    <br>
    A WorldObject can have references to WorldObject instances that
    don't have an id.<br>
    Inventory items are examples of WorldObject instances that don't
    have an id.<br>
    That's because the World instance doesn't directly contain them.<br>
    A WorldObject with an inventory property contains them.<br>
    <br>
    The method that creates the new WorldObject is placed in the
    org.worldgrower.generator package.<br>
    In that package are several classes that generate new WorldObjects
    like PlantGenerator or ItemGenerator.<br>
    <br>
    <h2><a name="Adding_a_new_Goal"></a>Adding a new Goal</h2>
    Create a new class under org.worldgrower.goal that implements the
    Goal interface.<br>
    <br>
    The method <u>calculateGoal</u> returns an OperationInfo instance
    which best describes how to attain the goal.<br>
    It shouldn't change any state in WorldObjects or elsewhere.<br>
    The Goal can depend on subgoals, for example when inventory items
    are needed.<br>
    The calculateGoal method should test whether anything is missing,
    and if it is, return subgoals.<br>
    If there is no way for the goal to be attained, null can be
    returned.<br>
    <br>
    The method <u>goalMetOrNot </u>is used to record whether some
    demands aren't being met.<br>
    For example: if the food goal isn't met, it can be added to the
    demands property.<br>
    The demands property is used to determine what goods are in demand,
    <br>
    and is used when intelligent WorldObjects choose a profession.<br>
    <br>
    The method <u>isGoalMet </u>indicates whether this goal is being
    met.<br>
    If it isn't being met, the calculateGoal method is called.<br>
    <br>
    Normally one goal is finished before the next goal is started.<br>
    If the method <u>isUrgentGoalMet</u> returns false, the current
    goal is aborted and the urgent goal is calculated.<br>
    <br>
    The method <u>getDescription</u> retrun a description of the goal
    like:<br>
    "I'm" + getDescription<br>
    For example: I'm looking for food<br>
    <br>
    The <u>evaluate</u> method indicates how much success there is in
    attaining the goal.<br>
    A higher number is better.<br>
    If someone does something which lowers this number, the person for
    which this goal is meant becomes unhappy.<br>
    <br>
    Once the class is implemented, it can be added to the Goals class.<br>
    After that, the constant in the Goals class can be added to other
    classes that provide Goals like<br>
    &nbsp;&nbsp;&nbsp; - CommonerWorldEvaluationFunction<br>
    &nbsp;&nbsp;&nbsp; - any of the Profession implementations if the
    Goal is related to a profession<br>
    <br>
    <h2><a name="Adding_a_new_Image"></a>Adding a new Image</h2>
    <br>
    Adding a new image means adding a new entry to ImageIds<br>
    and add the code to read in the image to ImageInfoReader.<br>
    <br>
    <h2><a name="Adding_a_new_Conversation"></a>Adding a new
      Conversation</h2>
    <br>
    Create a class under org.worldgrower.conversation or its subpackages
    that implements Conversation.<br>
    <br>
    The method <u>getQuestionPhrases</u> returns&nbsp; possible
    Questions for this conversation.<br>
    A Question contains a questionPhrase, the text that is actually
    presented to the target.<br>
    It also contains a subject, which is a WorldObject that is sent to
    the target when it has to reply.<br>
    It contains a similar field for HistoryItem, for when the conversion
    discusses an event that has happened.<br>
    And an additionalValue in case a Question needs it.<br>
    <br>
    The method <u>getReplyPhrase</u> returns a response, in case the
    question is asked to an intelligent WorldObject.<br>
    It's best to use the default method <u>getReply</u> like this:<br>
    final int replyId = ...;<br>
    return getReply(getReplyPhrases(conversationContext), replyId);<br>
    That way the replyPhrases aren't duplicated accross methods.<br>
    <br>
    The method <u>getReplyPhrases </u>returns multiple Responses.<br>
    Each Response has an id, which is the replyId used in the method <u>getReplyPhras</u><u>e</u>.<br>
    A response has the same fields as a question inclusing the
    historyItem and the subject.<br>
    It also has a boolean isPossible which indicates whether the
    Response is possible.<br>
    <br>
    The method <u>isConversationAvailable </u>indicates whether the
    conversation is available.<br>
    <br>
    The method <u>getDescription </u>describes the Conversation as if
    "I'm" is put before the description.<br>
    For example: I'm talking about my name<br>
    <br>
    <h2><a name="Adding_unit_tests"></a>Adding unit tests</h2>
    <br>
    All tests are under the test folder and follow a similar package
    structure as the source tree.<br>
    If the class you want to add a test for is already being tested, the
    test can simply be added to that class.<br>
    <br>
    If the class isn't yet being tested, it's best to add a new test
    class with prefix UTest.<br>
    To add the new class to the existing tests, just add it to the
    CompleteTestSuite class.<br>
  </body>
</html>
